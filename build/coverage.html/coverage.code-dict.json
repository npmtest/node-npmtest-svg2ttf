{"/home/travis/build/npmtest/node-npmtest-svg2ttf/test.js":"/* istanbul instrument in package npmtest_svg2ttf */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-svg2ttf/lib.npmtest_svg2ttf.js":"/* istanbul instrument in package npmtest_svg2ttf */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_svg2ttf = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_svg2ttf = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-svg2ttf/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-svg2ttf && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_svg2ttf */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_svg2ttf\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_svg2ttf.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_svg2ttf.rollup.js'] =\n            local.assetsDict['/assets.npmtest_svg2ttf.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_svg2ttf.__dirname + '/lib.npmtest_svg2ttf.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-svg2ttf/node_modules/svg2ttf/index.js":"/*\n * Copyright: Vitaly Puzrin\n * Author: Sergey Batishchev <snb2003@rambler.ru>\n *\n * Written for fontello.com project.\n */\n\n'use strict';\n\nvar _       = require('lodash');\nvar SvgPath = require('svgpath');\nvar ucs2 = require('./lib/ucs2');\nvar svg     = require('./lib/svg');\nvar sfnt    = require('./lib/sfnt');\n\n\nvar VERSION_RE = /^(Version )?(\\d+[.]\\d+)$/i;\n\n\nfunction svg2ttf(svgString, options) {\n  var font = new sfnt.Font();\n  var svgFont = svg.load(svgString);\n\n  options = options || {};\n\n  font.id = options.id || svgFont.id;\n  font.familyName = options.familyname || svgFont.familyName || svgFont.id;\n  font.copyright = options.copyright || svgFont.metadata;\n  font.sfntNames.push({ id: 2, value: options.subfamilyname || 'Regular' }); // subfamily name\n  font.sfntNames.push({ id: 4, value: options.fullname || svgFont.id }); // full name\n\n\n  var versionString = options.version || 'Version 1.0';\n\n  if (typeof versionString !== 'string') {\n    throw new Error('svg2ttf: version option should be a string');\n  }\n  if (!VERSION_RE.test(versionString)) {\n    throw new Error('svg2ttf: invalid option, version - \"' + options.version + '\"');\n  }\n\n  versionString = 'Version ' + versionString.match(VERSION_RE)[2];\n  font.sfntNames.push({ id: 5, value: versionString }); // version ID for TTF name table\n\n\n  font.sfntNames.push({ id: 6, value: options.fullname || svgFont.id }); // Postscript name for the font, required for OSX Font Book\n\n  if (typeof options.ts !== 'undefined') {\n    font.createdDate = font.modifiedDate = new Date(parseInt(options.ts, 10) * 1000);\n  }\n\n  // Try to fill font metrics or guess defaults\n  //\n  font.unitsPerEm   = svgFont.unitsPerEm || 1000;\n  font.horizOriginX = svgFont.horizOriginX || 0;\n  font.horizOriginY = svgFont.horizOriginY || 0;\n  font.vertOriginX  = svgFont.vertOriginX || 0;\n  font.vertOriginY  = svgFont.vertOriginY || 0;\n  // need to correctly convert text values, use default (400) until compleete\n  //font.weightClass = svgFont.weightClass;\n  font.width    = svgFont.width || svgFont.unitsPerEm;\n  font.height   = svgFont.height || svgFont.unitsPerEm;\n  font.descent  = !isNaN(svgFont.descent) ? svgFont.descent : -font.vertOriginY;\n  font.ascent   = svgFont.ascent || (font.unitsPerEm - font.vertOriginY);\n\n  var glyphs = font.glyphs;\n  var codePoints = font.codePoints;\n  var ligatures = font.ligatures;\n\n  function addCodePoint(codePoint, glyph) {\n    if (codePoints[codePoint]) {\n      // Ignore code points already defined\n      return false;\n    }\n    codePoints[codePoint] = glyph;\n    return true;\n  }\n\n  // add SVG glyphs to SFNT font\n  _.forEach(svgFont.glyphs, function (svgGlyph) {\n    var glyph = new sfnt.Glyph();\n\n    glyph.name = svgGlyph.name;\n    glyph.d = svgGlyph.d;\n    glyph.height = !isNaN(svgGlyph.height) ? svgGlyph.height : font.height;\n    glyph.width = !isNaN(svgGlyph.width) ? svgGlyph.width : font.width;\n    glyphs.push(glyph);\n\n    svgGlyph.sfntGlyph = glyph;\n\n    _.forEach(svgGlyph.unicode, function (codePoint) {\n      addCodePoint(codePoint, glyph);\n    });\n  });\n\n  var missingGlyph;\n\n  // add missing glyph to SFNT font\n  // also, check missing glyph existance and single instance\n  if (svgFont.missingGlyph) {\n    missingGlyph = new sfnt.Glyph();\n    missingGlyph.d = svgFont.missingGlyph.d;\n    missingGlyph.height = !isNaN(svgFont.missingGlyph.height) ? svgFont.missingGlyph.height : font.height;\n    missingGlyph.width = !isNaN(svgFont.missingGlyph.width) ? svgFont.missingGlyph.width : font.width;\n  } else {\n    missingGlyph = _.find(glyphs, function (glyph) {\n      return glyph.name === '.notdef';\n    });\n  }\n  if (!missingGlyph) { // no missing glyph and .notdef glyph, we need to create missing glyph\n    missingGlyph = new sfnt.Glyph();\n  }\n\n  // Create glyphs for all characters used in ligatures\n  _.forEach(svgFont.ligatures, function (svgLigature) {\n    var ligature = {\n      ligature: svgLigature.ligature,\n      unicode: svgLigature.unicode,\n      glyph: svgLigature.glyph.sfntGlyph\n    };\n\n    _.forEach(ligature.unicode, function (charPoint) {\n      // We need to have a distinct glyph for each code point so we can reference it in GSUB\n      var glyph = new sfnt.Glyph();\n      var added = addCodePoint(charPoint, glyph);\n\n      if (added) {\n        glyph.name = ucs2.encode([ charPoint ]);\n        glyphs.push(glyph);\n      }\n    });\n    ligatures.push(ligature);\n  });\n\n  // Missing Glyph needs to have index 0\n  if (glyphs.indexOf(missingGlyph) !== -1) {\n    glyphs.splice(glyphs.indexOf(missingGlyph), 1);\n  }\n  glyphs.unshift(missingGlyph);\n\n  var nextID = 0;\n\n  //add IDs\n  _.forEach(glyphs, function (glyph) {\n    glyph.id = nextID;\n    nextID++;\n  });\n\n  _.forEach(glyphs, function (glyph) {\n\n    // Calculate accuracy for cubicToQuad transformation\n    // For glyphs with height and width smaller than 500 use relative 0.06% accuracy,\n    // for larger glyphs use fixed accuracy 0.3.\n    var glyphSize = Math.max(glyph.width, glyph.height);\n    var accuracy = (glyphSize > 500) ? 0.3 : glyphSize * 0.0006;\n\n    //SVG transformations\n    var svgPath = new SvgPath(glyph.d)\n      .abs()\n      .unshort()\n      .unarc()\n      .iterate(function (segment, index, x, y) {\n        return svg.cubicToQuad(segment, index, x, y, accuracy);\n      });\n    var sfntContours = svg.toSfntCoutours(svgPath);\n\n    // Add contours to SFNT font\n    glyph.contours = _.map(sfntContours, function (sfntContour) {\n      var contour = new sfnt.Contour();\n\n      contour.points = _.map(sfntContour, function (sfntPoint) {\n        var point = new sfnt.Point();\n\n        point.x = sfntPoint.x;\n        point.y = sfntPoint.y;\n        point.onCurve = sfntPoint.onCurve;\n        return point;\n      });\n\n      return contour;\n    });\n  });\n\n  var ttf = sfnt.toTTF(font);\n\n  return ttf;\n}\n\nmodule.exports = svg2ttf;\n","/home/travis/build/npmtest/node-npmtest-svg2ttf/node_modules/svg2ttf/lib/ucs2.js":"'use strict';\n\nvar _ = require('lodash');\n\n// Taken from the punycode library\nfunction ucs2encode(array) {\n  return _.map(array, function (value) {\n    var output = '';\n\n    if (value > 0xFFFF) {\n      value -= 0x10000;\n      output += String.fromCharCode(value >>> 10 & 0x3FF | 0xD800);\n      value = 0xDC00 | value & 0x3FF;\n    }\n    output += String.fromCharCode(value);\n    return output;\n  }).join('');\n}\n\nfunction ucs2decode(string) {\n  var output = [],\n      counter = 0,\n      length = string.length,\n      value,\n      extra;\n\n  while (counter < length) {\n    value = string.charCodeAt(counter++);\n    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n      // high surrogate, and there is a next character\n      extra = string.charCodeAt(counter++);\n      if ((extra & 0xFC00) === 0xDC00) { // low surrogate\n        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n      } else {\n        // unmatched surrogate; only append this code unit, in case the next\n        // code unit is the high surrogate of a surrogate pair\n        output.push(value);\n        counter--;\n      }\n    } else {\n      output.push(value);\n    }\n  }\n  return output;\n}\n\nmodule.exports = {\n  encode: ucs2encode,\n  decode: ucs2decode\n};\n","/home/travis/build/npmtest/node-npmtest-svg2ttf/node_modules/svg2ttf/lib/svg.js":"'use strict';\n\nvar _ = require('lodash');\nvar cubic2quad = require('cubic2quad');\nvar DOMParser = require('xmldom').DOMParser;\nvar ucs2 = require('./ucs2');\n\nfunction getGlyph(glyphElem) {\n  var glyph = {};\n\n  glyph.d = glyphElem.getAttribute('d').trim();\n  glyph.unicode = [];\n\n  if (glyphElem.getAttribute('unicode')) {\n    glyph.character = glyphElem.getAttribute('unicode');\n    var unicode = ucs2.decode(glyph.character);\n\n    // If more than one code point is involved, the glyph is a ligature glyph\n    if (unicode.length > 1) {\n      glyph.ligature = glyph.character;\n      glyph.ligatureCodes = unicode;\n    } else {\n      glyph.unicode.push(unicode[0]);\n    }\n  }\n\n  glyph.name = glyphElem.getAttribute('glyph-name');\n\n  if (glyphElem.getAttribute('horiz-adv-x')) {\n    glyph.width = parseInt(glyphElem.getAttribute('horiz-adv-x'), 10);\n  }\n\n  return glyph;\n}\n\nfunction deduplicateGlyps(glyphs, ligatures) {\n  // Result (the list of unique glyphs)\n  var result = [];\n\n  _.forEach(glyphs, function (glyph) {\n    // Search for glyphs with the same properties (width and d)\n    var canonical = _.find(result, { width: glyph.width, d: glyph.d });\n\n    if (canonical) {\n      // Add the code points to the unicode array.\n      // The fields “name” and “character” are not that important so we leave them how we first enounter them and throw the rest away\n      canonical.unicode = canonical.unicode.concat(glyph.unicode);\n      glyph.canonical = canonical;\n    } else {\n      result.push(glyph);\n    }\n  });\n\n  // Update ligatures to point to the canonical version\n  _.forEach(ligatures, function (ligature) {\n    while (_.has(ligature.glyph, 'canonical')) {\n      ligature.glyph = ligature.glyph.canonical;\n    }\n  });\n\n  return result;\n}\n\nfunction load(str) {\n  var attrs;\n\n  var doc = (new DOMParser()).parseFromString(str, 'application/xml');\n\n  var metadata, fontElem, fontFaceElem;\n\n  metadata = doc.getElementsByTagName('metadata')[0];\n  fontElem = doc.getElementsByTagName('font')[0];\n\n  if (!fontElem) {\n    throw new Error(\"Can't find <font> tag. Make sure you SVG file is font, not image.\");\n  }\n\n  fontFaceElem = fontElem.getElementsByTagName('font-face')[0];\n\n  var font = {\n    id: fontElem.getAttribute('id') || 'fontello',\n    familyName: fontFaceElem.getAttribute('font-family') || 'fontello',\n    stretch: fontFaceElem.getAttribute('font-stretch') || 'normal'\n  };\n\n  // Doesn't work with complex content like <strong>Copyright:></strong><em>Fontello</em>\n  if (metadata && metadata.textContent) {\n    font.metadata = metadata.textContent;\n  }\n\n  // Get <font> numeric attributes\n  attrs = {\n    width:        'horiz-adv-x',\n    //height:       'vert-adv-y',\n    horizOriginX: 'horiz-origin-x',\n    horizOriginY: 'horiz-origin-y',\n    vertOriginX:  'vert-origin-x',\n    vertOriginY:  'vert-origin-y'\n  };\n  _.forEach(attrs, function (val, key) {\n    if (fontElem.hasAttribute(val)) { font[key] = parseInt(fontElem.getAttribute(val), 10); }\n  });\n\n  // Get <font-face> numeric attributes\n  attrs = {\n    ascent:     'ascent',\n    descent:    'descent',\n    unitsPerEm: 'units-per-em'\n  };\n  _.forEach(attrs, function (val, key) {\n    if (fontFaceElem.hasAttribute(val)) { font[key] = parseInt(fontFaceElem.getAttribute(val), 10); }\n  });\n\n  if (fontFaceElem.hasAttribute('font-weight')) {\n    font.weightClass = fontFaceElem.getAttribute('font-weight');\n  }\n\n  var missingGlyphElem = fontElem.getElementsByTagName('missing-glyph')[0];\n\n  if (missingGlyphElem) {\n\n    font.missingGlyph = {};\n    font.missingGlyph.d = missingGlyphElem.getAttribute('d') || '';\n\n    if (missingGlyphElem.getAttribute('horiz-adv-x')) {\n      font.missingGlyph.width = parseInt(missingGlyphElem.getAttribute('horiz-adv-x'), 10);\n    }\n  }\n\n  var glyphs = [];\n  var ligatures = [];\n\n  _.forEach(fontElem.getElementsByTagName('glyph'), function (glyphElem) {\n    var glyph = getGlyph(glyphElem);\n\n    if (_.has(glyph, 'ligature')) {\n      ligatures.push({\n        ligature: glyph.ligature,\n        unicode: glyph.ligatureCodes,\n        glyph: glyph\n      });\n    }\n\n    glyphs.push(glyph);\n  });\n\n  glyphs = deduplicateGlyps(glyphs, ligatures);\n\n  font.glyphs = glyphs;\n  font.ligatures = ligatures;\n\n  return font;\n}\n\n\nfunction cubicToQuad(segment, index, x, y, accuracy) {\n  if (segment[0] === 'C') {\n    var quadCurves = cubic2quad(\n      x, y,\n      segment[1], segment[2],\n      segment[3], segment[4],\n      segment[5], segment[6],\n      accuracy\n    );\n\n    var res = [];\n\n    for (var i = 2; i < quadCurves.length; i += 4) {\n      res.push([ 'Q', quadCurves[i], quadCurves[i + 1], quadCurves[i + 2], quadCurves[i + 3] ]);\n    }\n    return res;\n  }\n}\n\n\n// Converts svg points to contours.  All points must be converted\n// to relative ones, smooth curves must be converted to generic ones\n// before this conversion.\n//\nfunction toSfntCoutours(svgPath) {\n  var resContours = [];\n  var resContour = [];\n\n  svgPath.iterate(function (segment, index, x, y) {\n\n    //start new contour\n    if (index === 0 || segment[0] === 'M') {\n      resContour = [];\n      resContours.push(resContour);\n    }\n\n    var name = segment[0];\n\n    if (name === 'Q') {\n      //add control point of quad spline, it is not on curve\n      resContour.push({ x: segment[1], y: segment[2], onCurve: false });\n    }\n\n    // add on-curve point\n    if (name === 'H') {\n      // vertical line has Y coordinate only, X remains the same\n      resContour.push({ x: segment[1], y: y, onCurve: true });\n    } else if (name === 'V') {\n      // horizontal line has X coordinate only, Y remains the same\n      resContour.push({ x: x, y: segment[1], onCurve: true });\n    } else if (name !== 'Z') {\n      // for all commands (except H and V) X and Y are placed in the end of the segment\n      resContour.push({ x: segment[segment.length - 2], y: segment[segment.length - 1], onCurve: true });\n    }\n\n  });\n  return resContours;\n}\n\n\nmodule.exports.load = load;\nmodule.exports.cubicToQuad = cubicToQuad;\nmodule.exports.toSfntCoutours = toSfntCoutours;\n","/home/travis/build/npmtest/node-npmtest-svg2ttf/node_modules/svg2ttf/lib/sfnt.js":"'use strict';\n\nvar _ = require('lodash');\n\nfunction Font() {\n  this.ascent = 850;\n  this.copyright = '';\n  this.createdDate = new Date();\n  this.glyphs = [];\n  this.ligatures = [];\n  // Maping of code points to glyphs.\n  // Keys are actually numeric, thus should be `parseInt`ed.\n  this.codePoints = {};\n  this.isFixedPitch = 0;\n  this.italicAngle = 0;\n  this.familyClass = 0; // No Classification\n  this.familyName = '';\n  this.fsSelection = 0x40; // Characters are in the standard weight/style for the font.\n  // Non zero value can cause issues in IE, https://github.com/fontello/svg2ttf/issues/45\n  this.fsType = 0;\n  this.lowestRecPPEM = 8;\n  this.macStyle = 0;\n  this.modifiedDate = new Date();\n  this.panose = {\n    familyType: 2, // Latin Text\n    serifStyle: 0, // any\n    weight: 5, // book\n    proportion: 3, //modern\n    contrast: 0, //any\n    strokeVariation: 0, //any,\n    armStyle: 0, //any,\n    letterform: 0, //any,\n    midline: 0, //any,\n    xHeight: 0 //any,\n  };\n  this.revision = 1;\n  this.sfntNames = [];\n  this.underlineThickness = 0;\n  this.unitsPerEm = 1000;\n  this.weightClass = 400; // normal\n  this.width = 1000;\n  this.widthClass = 5; // Medium (normal)\n  this.ySubscriptXOffset = 0;\n  this.ySuperscriptXOffset = 0;\n  this.int_descent = -150;\n\n//getters and setters\n\n  Object.defineProperty(this, 'descent', {\n    get: function () {\n      return this.int_descent;\n    },\n    set: function (value) {\n      this.int_descent = parseInt(Math.round(-Math.abs(value)), 10);\n    }\n  });\n\n  this.__defineGetter__('avgCharWidth', function () {\n    if (this.glyphs.length === 0) {\n      return 0;\n    }\n    var widths = _.map(this.glyphs, 'width');\n\n    return parseInt(widths.reduce(function (prev, cur) {\n      return prev + cur;\n    }) / widths.length, 10);\n  });\n\n  Object.defineProperty(this, 'ySubscriptXSize', {\n    get: function () {\n      return parseInt(!_.isUndefined(this.int_ySubscriptXSize) ? this.int_ySubscriptXSize : (this.width * 0.6347), 10);\n    },\n    set: function (value) {\n      this.int_ySubscriptXSize = value;\n    }\n  });\n\n  Object.defineProperty(this, 'ySubscriptYSize', {\n    get: function () {\n      return parseInt(!_.isUndefined(this.int_ySubscriptYSize) ? this.int_ySubscriptYSize : ((this.ascent - this.descent) * 0.7), 10);\n    },\n    set: function (value) {\n      this.int_ySubscriptYSize = value;\n    }\n  });\n\n  Object.defineProperty(this, 'ySubscriptYOffset', {\n    get: function () {\n      return parseInt(!_.isUndefined(this.int_ySubscriptYOffset) ? this.int_ySubscriptYOffset : ((this.ascent - this.descent) * 0.14), 10);\n    },\n    set: function (value) {\n      this.int_ySubscriptYOffset = value;\n    }\n  });\n\n  Object.defineProperty(this, 'ySuperscriptXSize', {\n    get: function () {\n      return parseInt(!_.isUndefined(this.int_ySuperscriptXSize) ? this.int_ySuperscriptXSize : (this.width * 0.6347), 10);\n    },\n    set: function (value) {\n      this.int_ySuperscriptXSize = value;\n    }\n  });\n\n  Object.defineProperty(this, 'ySuperscriptYSize', {\n    get: function () {\n      return parseInt(!_.isUndefined(this.int_ySuperscriptYSize) ? this.int_ySuperscriptYSize : ((this.ascent - this.descent) * 0.7), 10);\n    },\n    set: function (value) {\n      this.int_ySuperscriptYSize = value;\n    }\n  });\n\n  Object.defineProperty(this, 'ySuperscriptYOffset', {\n    get: function () {\n      return parseInt(!_.isUndefined(this.int_ySuperscriptYOffset) ? this.int_ySuperscriptYOffset : ((this.ascent - this.descent) * 0.48), 10);\n    },\n    set: function (value) {\n      this.int_ySuperscriptYOffset = value;\n    }\n  });\n\n  Object.defineProperty(this, 'yStrikeoutSize', {\n    get: function () {\n      return parseInt(!_.isUndefined(this.int_yStrikeoutSize) ? this.int_yStrikeoutSize : ((this.ascent - this.descent) * 0.049), 10);\n    },\n    set: function (value) {\n      this.int_yStrikeoutSize = value;\n    }\n  });\n\n  Object.defineProperty(this, 'yStrikeoutPosition', {\n    get: function () {\n      return parseInt(!_.isUndefined(this.int_yStrikeoutPosition) ? this.int_yStrikeoutPosition : ((this.ascent - this.descent) * 0.258), 10);\n    },\n    set: function (value) {\n      this.int_yStrikeoutPosition = value;\n    }\n  });\n\n  Object.defineProperty(this, 'minLsb', {\n    get: function () {\n      return parseInt(_.min(_.map(this.glyphs, 'xMin')), 10);\n    }\n  });\n\n  Object.defineProperty(this, 'minRsb', {\n    get: function () {\n      if (!this.glyphs.length) return parseInt(this.width, 10);\n\n      return parseInt(_.reduce(this.glyphs, function (minRsb, glyph) {\n        return Math.min(minRsb, glyph.width - glyph.xMax);\n      }, 0), 10);\n    }\n  });\n\n  Object.defineProperty(this, 'xMin', {\n    get: function () {\n      if (!this.glyphs.length) return this.width;\n\n      return _.reduce(this.glyphs, function (xMin, glyph) {\n        return Math.min(xMin, glyph.xMin);\n      }, 0);\n    }\n  });\n\n  Object.defineProperty(this, 'yMin', {\n    get: function () {\n      if (!this.glyphs.length) return this.width;\n\n      return _.reduce(this.glyphs, function (yMin, glyph) {\n        return Math.min(yMin, glyph.yMin);\n      }, 0);\n    }\n  });\n\n  Object.defineProperty(this, 'xMax', {\n    get: function () {\n      if (!this.glyphs.length) return this.width;\n\n      return _.reduce(this.glyphs, function (xMax, glyph) {\n        return Math.max(xMax, glyph.xMax);\n      }, 0);\n    }\n  });\n\n  Object.defineProperty(this, 'yMax', {\n    get: function () {\n      if (!this.glyphs.length) return this.width;\n\n      return _.reduce(this.glyphs, function (yMax, glyph) {\n        return Math.max(yMax, glyph.yMax);\n      }, 0);\n    }\n  });\n\n  Object.defineProperty(this, 'avgWidth', {\n    get: function () {\n      var len = this.glyphs.length;\n\n      if (len === 0) {\n        return this.width;\n      }\n\n      var sumWidth = _.reduce(this.glyphs, function (sumWidth, glyph) {\n        return sumWidth + glyph.width;\n      }, 0);\n\n      return Math.round(sumWidth / len);\n    }\n  });\n\n  Object.defineProperty(this, 'maxWidth', {\n    get: function () {\n      if (!this.glyphs.length) return this.width;\n\n      return _.reduce(this.glyphs, function (maxWidth, glyph) {\n        return Math.max(maxWidth, glyph.width);\n      }, 0);\n    }\n  });\n\n  Object.defineProperty(this, 'maxExtent', {\n    get: function () {\n      if (!this.glyphs.length) return this.width;\n\n      return _.reduce(this.glyphs, function (maxExtent, glyph) {\n        return Math.max(maxExtent, glyph.xMax /*- glyph.xMin*/);\n      }, 0);\n    }\n  });\n\n  // Property used for `sTypoLineGap` in OS/2 and not used for `lineGap` in HHEA, because\n  // non zero lineGap causes bad offset in IE, https://github.com/fontello/svg2ttf/issues/37\n  Object.defineProperty(this, 'lineGap', {\n    get: function () {\n      return parseInt(!_.isUndefined(this.int_lineGap) ? this.int_lineGap : ((this.ascent - this.descent) * 0.09), 10);\n    },\n    set: function (value) {\n      this.int_lineGap = value;\n    }\n  });\n\n  Object.defineProperty(this, 'underlinePosition', {\n    get: function () {\n      return parseInt(!_.isUndefined(this.int_underlinePosition) ? this.int_underlinePosition : ((this.ascent - this.descent) * 0.01), 10);\n    },\n    set: function (value) {\n      this.int_underlinePosition = value;\n    }\n  });\n}\n\n\nfunction Glyph() {\n  this.contours = [];\n  this.d = '';\n  this.id = '';\n  this.height = 0;\n  this.name = '';\n  this.width = 0;\n}\n\nObject.defineProperty(Glyph.prototype, 'xMin', {\n  get: function () {\n    var xMin = 0;\n    var hasPoints = false;\n\n    _.forEach(this.contours, function (contour) {\n      _.forEach(contour.points, function (point) {\n        xMin = Math.min(xMin, Math.floor(point.x));\n        hasPoints = true;\n      });\n\n    });\n    return hasPoints ? xMin : 0;\n  }\n});\n\nObject.defineProperty(Glyph.prototype, 'xMax', {\n  get: function () {\n    var xMax = 0;\n    var hasPoints = false;\n\n    _.forEach(this.contours, function (contour) {\n      _.forEach(contour.points, function (point) {\n        xMax = Math.max(xMax, -Math.floor(-point.x));\n        hasPoints = true;\n      });\n\n    });\n    return hasPoints ? xMax : this.width;\n  }\n});\n\nObject.defineProperty(Glyph.prototype, 'yMin', {\n  get: function () {\n    var yMin = 0;\n    var hasPoints = false;\n\n    _.forEach(this.contours, function (contour) {\n      _.forEach(contour.points, function (point) {\n        yMin = Math.min(yMin, Math.floor(point.y));\n        hasPoints = true;\n      });\n\n    });\n    return hasPoints ? yMin : 0;\n  }\n});\n\nObject.defineProperty(Glyph.prototype, 'yMax', {\n  get: function () {\n    var yMax = 0;\n    var hasPoints = false;\n\n    _.forEach(this.contours, function (contour) {\n      _.forEach(contour.points, function (point) {\n        yMax = Math.max(yMax, -Math.floor(-point.y));\n        hasPoints = true;\n      });\n\n    });\n    return hasPoints ? yMax : 0;\n  }\n});\n\nfunction Contour() {\n  this.points = [];\n}\n\nfunction Point() {\n  this.onCurve = true;\n  this.x = 0;\n  this.y = 0;\n}\n\nfunction SfntName() {\n  this.id = 0;\n  this.value = '';\n}\n\nmodule.exports.Font = Font;\nmodule.exports.Glyph = Glyph;\nmodule.exports.Contour = Contour;\nmodule.exports.Point = Point;\nmodule.exports.SfntName = SfntName;\nmodule.exports.toTTF = require('./ttf');\n","/home/travis/build/npmtest/node-npmtest-svg2ttf/node_modules/svg2ttf/lib/ttf.js":"'use strict';\n\nvar _ = require('lodash');\nvar ByteBuffer = require('microbuffer');\n\nvar createGSUBTable    = require('./ttf/tables/gsub');\nvar createOS2Table    = require('./ttf/tables/os2');\nvar createCMapTable   = require('./ttf/tables/cmap');\nvar createGlyfTable   = require('./ttf/tables/glyf');\nvar createHeadTable   = require('./ttf/tables/head');\nvar createHHeadTable  = require('./ttf/tables/hhea');\nvar createHtmxTable   = require('./ttf/tables/hmtx');\nvar createLocaTable   = require('./ttf/tables/loca');\nvar createMaxpTable   = require('./ttf/tables/maxp');\nvar createNameTable   = require('./ttf/tables/name');\nvar createPostTable   = require('./ttf/tables/post');\n\nvar utils = require('./ttf/utils');\n\n// Tables\nvar TABLES = [\n  { innerName: 'GSUB', order: 4,  create: createGSUBTable  }, // GSUB\n  { innerName: 'OS/2', order: 4,  create: createOS2Table   }, // OS/2\n  { innerName: 'cmap', order: 6,  create: createCMapTable  }, // cmap\n  { innerName: 'glyf', order: 8,  create: createGlyfTable  }, // glyf\n  { innerName: 'head', order: 2,  create: createHeadTable  }, // head\n  { innerName: 'hhea', order: 1,  create: createHHeadTable }, // hhea\n  { innerName: 'hmtx', order: 5,  create: createHtmxTable  }, // hmtx\n  { innerName: 'loca', order: 7,  create: createLocaTable  }, // loca\n  { innerName: 'maxp', order: 3,  create: createMaxpTable  }, // maxp\n  { innerName: 'name', order: 9,  create: createNameTable  }, // name\n  { innerName: 'post', order: 10, create: createPostTable  }  // post\n];\n\n// Various constants\nvar CONST = {\n  VERSION: 0x10000,\n  CHECKSUM_ADJUSTMENT: 0xB1B0AFBA\n};\n\nfunction ulong(t) {\n  t &= 0xffffffff;\n  if (t < 0) {\n    t += 0x100000000;\n  }\n  return t;\n}\n\nfunction calc_checksum(buf) {\n  var sum = 0;\n  var nlongs = Math.floor(buf.length / 4);\n  var i;\n\n  for (i = 0; i < nlongs; ++i) {\n    var t = buf.getUint32(i * 4);\n\n    sum = ulong(sum + t);\n  }\n\n  var leftBytes = buf.length - nlongs * 4; //extra 1..3 bytes found, because table is not aligned. Need to include them in checksum too.\n\n  if (leftBytes > 0) {\n    var leftRes = 0;\n\n    for (i = 0; i < 4; i++) {\n      leftRes = (leftRes << 8) + ((i < leftBytes) ? buf.getUint8(nlongs * 4 + i) : 0);\n    }\n    sum = ulong(sum + leftRes);\n  }\n  return sum;\n}\n\nfunction generateTTF(font) {\n\n  // Prepare TTF contours objects. Note, that while sfnt countours are classes,\n  // ttf contours are just plain arrays of points\n  _.forEach(font.glyphs, function (glyph) {\n    glyph.ttfContours = _.map(glyph.contours, function (contour) {\n      return contour.points;\n    });\n  });\n\n  // Process ttf contours data\n  _.forEach(font.glyphs, function (glyph) {\n\n    // 0.3px accuracy is ok. fo 1000x1000.\n    glyph.ttfContours = utils.simplify(glyph.ttfContours, 0.3);\n    glyph.ttfContours = utils.simplify(glyph.ttfContours, 0.3); // one pass is not enougth\n\n    // Interpolated points can be removed. 1.1px is acceptable\n    // measure - it will give us 1px error after coordinates rounding.\n    glyph.ttfContours = utils.interpolate(glyph.ttfContours, 1.1);\n\n    glyph.ttfContours = utils.roundPoints(glyph.ttfContours);\n    glyph.ttfContours = utils.removeClosingReturnPoints(glyph.ttfContours);\n    glyph.ttfContours = utils.toRelative(glyph.ttfContours);\n  });\n\n  // Add tables\n  var headerSize = 12 + 16 * TABLES.length; // TTF header plus table headers\n  var bufSize = headerSize;\n\n  _.forEach(TABLES, function (table) {\n    //store each table in its own buffer\n    table.buffer = table.create(font);\n    table.length = table.buffer.length;\n    table.corLength = table.length + (4 - table.length % 4) % 4; // table size should be divisible to 4\n    table.checkSum = calc_checksum(table.buffer);\n    bufSize += table.corLength;\n  });\n\n  //calculate offsets\n  var offset = headerSize;\n\n  _.forEach(_.sortBy(TABLES, 'order'), function (table) {\n    table.offset = offset;\n    offset += table.corLength;\n  });\n\n  //create TTF buffer\n\n  var buf = new ByteBuffer(bufSize);\n\n  //special constants\n  var entrySelector = Math.floor(Math.log(TABLES.length) / Math.LN2);\n  var searchRange = Math.pow(2, entrySelector) * 16;\n  var rangeShift = TABLES.length * 16 - searchRange;\n\n  // Add TTF header\n  buf.writeUint32(CONST.VERSION);\n  buf.writeUint16(TABLES.length);\n  buf.writeUint16(searchRange);\n  buf.writeUint16(entrySelector);\n  buf.writeUint16(rangeShift);\n\n  _.forEach(TABLES, function (table) {\n    buf.writeUint32(utils.identifier(table.innerName)); //inner name\n    buf.writeUint32(table.checkSum); //checksum\n    buf.writeUint32(table.offset); //offset\n    buf.writeUint32(table.length); //length\n  });\n\n  var headOffset = 0;\n\n  _.forEach(_.sortBy(TABLES, 'order'), function (table) {\n    if (table.innerName === 'head') { //we must store head offset to write font checksum\n      headOffset = buf.tell();\n    }\n    buf.writeBytes(table.buffer.buffer);\n    for (var i = table.length; i < table.corLength; i++) { //align table to be divisible to 4\n      buf.writeUint8(0);\n    }\n  });\n\n  // Write font checksum (corrected by magic value) into HEAD table\n  buf.setUint32(headOffset + 8, ulong(CONST.CHECKSUM_ADJUSTMENT - calc_checksum(buf)));\n\n  return buf;\n}\n\nmodule.exports = generateTTF;\n","/home/travis/build/npmtest/node-npmtest-svg2ttf/node_modules/svg2ttf/lib/ttf/tables/gsub.js":"'use strict';\n\n// See documentation here: http://www.microsoft.com/typography/otspec/GSUB.htm\n\nvar _ = require('lodash');\nvar identifier = require('../utils.js').identifier;\nvar ByteBuffer = require('microbuffer');\n\nfunction createScript() {\n  var scriptRecord = (0\n    + 2 // Script DefaultLangSys Offset\n    + 2 // Script[0] LangSysCount (0)\n  );\n\n  var langSys = (0\n    + 2 // Script DefaultLangSys LookupOrder\n    + 2 // Script DefaultLangSys ReqFeatureIndex\n    + 2 // Script DefaultLangSys FeatureCount (0?)\n    + 2 // Script Optional Feature Index[0]\n  );\n\n  var length = (0\n    + scriptRecord\n    + langSys\n  );\n\n  var buffer = new ByteBuffer(length);\n\n  // Script Record\n  // Offset to the start of langSys from the start of scriptRecord\n  buffer.writeUint16(scriptRecord); // DefaultLangSys\n\n  // Number of LangSys entries other than the default (none)\n  buffer.writeUint16(0);\n\n  // LangSys record (DefaultLangSys)\n  // LookupOrder\n  buffer.writeUint16(0);\n  // ReqFeatureIndex -> only one required feature: all ligatures\n  buffer.writeUint16(0);\n  // Number of FeatureIndex values for this language system (excludes the required feature)\n  buffer.writeUint16(1);\n  // FeatureIndex for the first optional feature\n  // Note: Adding the same feature to both the optional\n  // and the required features is a clear violation of the spec\n  // but it fixes IE not displaying the ligatures.\n  // See http://partners.adobe.com/public/developer/opentype/index_table_formats.html, Section “Language System Table”\n  // “FeatureCount: Number of FeatureIndex values for this language system-*excludes the required feature*” (emphasis added)\n  buffer.writeUint16(0);\n\n  return buffer;\n}\n\nfunction createScriptList() {\n  var scriptSize = (0\n    + 4 // Tag\n    + 2 // Offset\n  );\n\n  var scripts = [ [ 'latn', createScript() ], [ 'DFLT', createScript() ] ];\n\n  var header = (0\n    + 2 // Script count\n    + scripts.length * scriptSize\n  );\n\n  var tableLengths = _.reduce(_.map(scripts, function (script) { return script[1].length; }), function (result, count) { return result + count; }, 0);\n\n  var length = (0\n    + header\n    + tableLengths\n  );\n\n  var buffer = new ByteBuffer(length);\n\n  // Script count\n  buffer.writeUint16(scripts.length);\n\n  // Write all ScriptRecords\n  var offset = header;\n\n  _.forEach(scripts, function (script) {\n    var name = script[0], table = script[1];\n\n    // Script identifier (DFLT/latn)\n    buffer.writeUint32(identifier(name));\n    // Offset to the ScriptRecord from start of the script list\n    buffer.writeUint16(offset);\n    // Increment offset by script table length\n    offset += table.length;\n  });\n\n  // Write all ScriptTables\n  _.forEach(scripts, function (script) {\n    var table = script[1];\n\n    buffer.writeBytes(table.buffer);\n  });\n\n  return buffer;\n}\n\n// Write one feature containing all ligatures\nfunction createFeatureList() {\n  var header = (0\n    + 2 // FeatureCount\n    + 4 // FeatureTag[0]\n    + 2 // Feature Offset[0]\n  );\n\n  var length = (0\n    + header\n    + 2 // FeatureParams[0]\n    + 2 // LookupCount[0]\n    + 2 // Lookup[0] LookupListIndex[0]\n  );\n\n  var buffer = new ByteBuffer(length);\n\n  // FeatureCount\n  buffer.writeUint16(1);\n  // FeatureTag[0]\n  buffer.writeUint32(identifier('liga'));\n  // Feature Offset[0]\n  buffer.writeUint16(header);\n  // FeatureParams[0]\n  buffer.writeUint16(0);\n  // LookupCount[0]\n  buffer.writeUint16(1);\n  // Index into lookup table. Since we only have ligatures, the index is always 0\n  buffer.writeUint16(0);\n\n  return buffer;\n}\n\nfunction createLigatureCoverage(font, ligatureGroups) {\n  var glyphCount = ligatureGroups.length;\n\n  var length = (0\n    + 2 // CoverageFormat\n    + 2 // GlyphCount\n    + 2 * glyphCount // GlyphID[i]\n  );\n\n  var buffer = new ByteBuffer(length);\n\n  // CoverageFormat\n  buffer.writeUint16(1);\n\n  // Length\n  buffer.writeUint16(glyphCount);\n\n\n  _.forEach(ligatureGroups, function (group) {\n    buffer.writeUint16(group.startGlyph.id);\n  });\n\n  return buffer;\n}\n\nfunction createLigatureTable(font, ligature) {\n  var allCodePoints = font.codePoints;\n\n  var unicode = ligature.unicode;\n\n  var length = (0\n    + 2 // LigGlyph\n    + 2 // CompCount\n    + 2 * (unicode.length - 1)\n  );\n\n  var buffer = new ByteBuffer(length);\n\n  // LigGlyph\n  var glyph = ligature.glyph;\n\n  buffer.writeUint16(glyph.id);\n\n  // CompCount\n  buffer.writeUint16(unicode.length);\n\n  // Compound glyphs (excluding first as it’s already in the coverage table)\n  for (var i = 1; i < unicode.length; i++) {\n    glyph = allCodePoints[unicode[i]];\n    buffer.writeUint16(glyph.id);\n  }\n\n  return buffer;\n}\n\nfunction createLigatureSet(font, codePoint, ligatures) {\n  var ligatureTables = [];\n\n  _.forEach(ligatures, function (ligature) {\n    ligatureTables.push(createLigatureTable(font, ligature));\n  });\n\n  var tableLengths = _.reduce(_.map(ligatureTables, 'length'), function (result, count) { return result + count; }, 0);\n\n  var offset = (0\n    + 2 // LigatureCount\n    + 2 * ligatures.length\n  );\n\n  var length = (0\n    + offset\n    + tableLengths\n  );\n\n  var buffer = new ByteBuffer(length);\n\n  // LigatureCount\n  buffer.writeUint16(ligatures.length);\n\n  // Ligature offsets\n  _.forEach(ligatureTables, function (table) {\n    // The offset to the current set, from SubstFormat\n    buffer.writeUint16(offset);\n    offset += table.length;\n  });\n\n  // Ligatures\n  _.forEach(ligatureTables, function (table) {\n    buffer.writeBytes(table.buffer);\n  });\n\n  return buffer;\n}\n\nfunction createLigatureList(font, ligatureGroups) {\n  var sets = [];\n\n  _.forEach(ligatureGroups, function (group) {\n    var set = createLigatureSet(font, group.codePoint, group.ligatures);\n\n    sets.push(set);\n  });\n\n  var setLengths = _.reduce(_.map(sets, 'length'), function (result, count) { return result + count; }, 0);\n\n  var coverage = createLigatureCoverage(font, ligatureGroups);\n\n  var tableOffset = (0\n    + 2 // Lookup type\n    + 2 // Lokup flag\n    + 2 // SubTableCount\n    + 2 // SubTable[0] Offset\n  );\n\n  var setOffset = (0\n    + 2 // SubstFormat\n    + 2 // Coverage offset\n    + 2 // LigSetCount\n    + 2 * sets.length // LigSet Offsets\n  );\n\n  var coverageOffset = setOffset + setLengths;\n\n  var length = (0\n    + tableOffset\n    + coverageOffset\n    + coverage.length\n  );\n\n  var buffer = new ByteBuffer(length);\n\n  // Lookup type 4 – ligatures\n  buffer.writeUint16(4);\n\n  // Lookup flag – empty\n  buffer.writeUint16(0);\n\n  // Subtable count\n  buffer.writeUint16(1);\n\n  // Subtable[0] offset\n  buffer.writeUint16(tableOffset);\n\n  // SubstFormat\n  buffer.writeUint16(1);\n\n  // Coverage\n  buffer.writeUint16(coverageOffset);\n\n  // LigSetCount\n  buffer.writeUint16(sets.length);\n\n  _.forEach(sets, function (set) {\n    // The offset to the current set, from SubstFormat\n    buffer.writeUint16(setOffset);\n    setOffset += set.length;\n  });\n\n  _.forEach(sets, function (set) {\n    buffer.writeBytes(set.buffer);\n  });\n\n  buffer.writeBytes(coverage.buffer);\n\n  return buffer;\n}\n\n// Add a lookup for each ligature\nfunction createLookupList(font) {\n  var ligatures = font.ligatures;\n\n  var groupedLigatures = {};\n\n  // Group ligatures by first code point\n  _.forEach(ligatures, function (ligature) {\n    var first = ligature.unicode[0];\n\n    if (!_.has(groupedLigatures, first)) {\n      groupedLigatures[first] = [];\n    }\n    groupedLigatures[first].push(ligature);\n  });\n\n  var ligatureGroups = [];\n\n  _.forEach(groupedLigatures, function (ligatures, codePoint) {\n    codePoint = parseInt(codePoint, 10);\n    // Order ligatures by length, descending\n    // “Ligatures with more components must be stored ahead of those with fewer components in order to be found”\n    // From: http://partners.adobe.com/public/developer/opentype/index_tag7.html#liga\n    ligatures.sort(function (ligA, ligB) {\n      return ligB.unicode.length - ligA.unicode.length;\n    });\n    ligatureGroups.push({\n      codePoint: codePoint,\n      ligatures: ligatures,\n      startGlyph: font.codePoints[codePoint]\n    });\n  });\n\n  ligatureGroups.sort(function (a, b) {\n    return a.startGlyph.id - b.startGlyph.id;\n  });\n\n  var offset = (0\n    + 2 // Lookup count\n    + 2 // Lookup[0] offset\n  );\n\n  var set = createLigatureList(font, ligatureGroups);\n\n  var length = (0\n    + offset\n    + set.length\n  );\n\n  var buffer = new ByteBuffer(length);\n\n  // Lookup count\n  buffer.writeUint16(1);\n\n  // Lookup[0] offset\n  buffer.writeUint16(offset);\n\n  // Lookup[0]\n  buffer.writeBytes(set.buffer);\n\n  return buffer;\n}\n\nfunction createGSUB(font) {\n  var scriptList = createScriptList();\n  var featureList = createFeatureList();\n  var lookupList = createLookupList(font);\n\n  var lists = [ scriptList, featureList, lookupList ];\n\n  var offset = (0\n    + 4 // Version\n    + 2 * lists.length // List offsets\n  );\n\n  // Calculate offsets\n  _.forEach(lists, function (list) {\n    list._listOffset = offset;\n    offset += list.length;\n  });\n\n  var length = offset;\n  var buffer = new ByteBuffer(length);\n\n  // Version\n  buffer.writeUint32(0x00010000);\n\n  // Offsets\n  _.forEach(lists, function (list) {\n    buffer.writeUint16(list._listOffset);\n  });\n\n  // List contents\n  _.forEach(lists, function (list) {\n    buffer.writeBytes(list.buffer);\n  });\n\n  return buffer;\n}\n\nmodule.exports = createGSUB;\n","/home/travis/build/npmtest/node-npmtest-svg2ttf/node_modules/svg2ttf/lib/ttf/utils.js":"'use strict';\n\nvar _ = require('lodash');\nvar math = require('../math');\n\n// Remove points, that looks like straight line\nfunction simplify(contours, accuracy) {\n  return _.map(contours, function (contour) {\n    var i, curr, prev, next;\n    var p, pPrev, pNext;\n\n    // run from the end, to simplify array elements removal\n    for (i = contour.length - 2; i > 1; i--) {\n      prev = contour[i - 1];\n      next = contour[i + 1];\n      curr = contour[i];\n\n      // skip point (both oncurve & offcurve),\n      // if [prev,next] is straight line\n      if (prev.onCurve && next.onCurve) {\n        p = new math.Point(curr.x, curr.y);\n        pPrev = new math.Point(prev.x, prev.y);\n        pNext = new math.Point(next.x, next.y);\n        if (math.isInLine(pPrev, p, pNext, accuracy)) {\n          contour.splice(i, 1);\n        }\n      }\n    }\n    return contour;\n  });\n}\n\n// Remove interpolateable oncurve points\n// Those should be in the middle of nebor offcurve points\nfunction interpolate(contours, accuracy) {\n  return _.map(contours, function (contour) {\n    var resContour = [];\n\n    _.forEach(contour, function (point, idx) {\n      // Never skip first and last points\n      if (idx === 0 || idx === (contour.length - 1)) {\n        resContour.push(point);\n        return;\n      }\n\n      var prev = contour[idx - 1];\n      var next = contour[idx + 1];\n\n      var p, pPrev, pNext;\n\n      // skip interpolateable oncurve points (if exactly between previous and next offcurves)\n      if (!prev.onCurve && point.onCurve && !next.onCurve) {\n        p = new math.Point(point.x, point.y);\n        pPrev = new math.Point(prev.x, prev.y);\n        pNext = new math.Point(next.x, next.y);\n        if (pPrev.add(pNext).div(2).sub(p).dist() < accuracy) {\n          return;\n        }\n      }\n      // keep the rest\n      resContour.push(point);\n    });\n    return resContour;\n  });\n}\n\nfunction roundPoints(contours) {\n  return _.map(contours, function (contour) {\n    return _.map(contour, function (point) {\n      return { x: Math.round(point.x), y: Math.round(point.y), onCurve: point.onCurve };\n    });\n  });\n}\n\n// Remove closing point if it is the same as first point of contour.\n// TTF doesn't need this point when drawing contours.\nfunction removeClosingReturnPoints(contours) {\n  return _.map(contours, function (contour) {\n    var length = contour.length;\n\n    if (length > 1 &&\n      contour[0].x === contour[length - 1].x &&\n      contour[0].y === contour[length - 1].y) {\n      contour.splice(length - 1);\n    }\n    return contour;\n  });\n}\n\nfunction toRelative(contours) {\n  var prevPoint = { x: 0, y: 0 };\n  var resContours = [];\n  var resContour;\n\n  _.forEach(contours, function (contour) {\n    resContour = [];\n    resContours.push(resContour);\n    _.forEach(contour, function (point) {\n      resContour.push({\n        x: point.x - prevPoint.x,\n        y: point.y - prevPoint.y,\n        onCurve: point.onCurve\n      });\n      prevPoint = point;\n    });\n  });\n  return resContours;\n}\n\nfunction identifier(string, littleEndian) {\n  var result = 0;\n\n  for (var i = 0; i < string.length; i++) {\n    result = result << 8;\n    var index = littleEndian ? string.length - i - 1 : i;\n\n    result += string.charCodeAt(index);\n  }\n\n  return result;\n}\n\nmodule.exports.interpolate = interpolate;\nmodule.exports.simplify = simplify;\nmodule.exports.roundPoints = roundPoints;\nmodule.exports.removeClosingReturnPoints = removeClosingReturnPoints;\nmodule.exports.toRelative = toRelative;\nmodule.exports.identifier = identifier;\n\n","/home/travis/build/npmtest/node-npmtest-svg2ttf/node_modules/svg2ttf/lib/math.js":"'use strict';\n\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.add = function (point) {\n  return new Point(this.x + point.x, this.y + point.y);\n};\n\nPoint.prototype.sub = function (point) {\n  return new Point(this.x - point.x, this.y - point.y);\n};\n\nPoint.prototype.mul = function (value) {\n  return new Point(this.x * value, this.y * value);\n};\n\nPoint.prototype.div = function (value) {\n  return new Point(this.x / value, this.y / value);\n};\n\nPoint.prototype.dist = function () {\n  return Math.sqrt(this.x * this.x + this.y * this.y);\n};\n\nPoint.prototype.sqr = function () {\n  return this.x * this.x + this.y * this.y;\n};\n\n/*\n * Check if 3 points are in line, and second in the midle.\n * Used to replace quad curves with lines or join lines\n *\n */\nfunction isInLine(p1, m, p2, accuracy) {\n  var a = p1.sub(m).sqr();\n  var b = p2.sub(m).sqr();\n  var c = p1.sub(p2).sqr();\n\n  // control point not between anchors\n  if ((a > (b + c)) || (b > (a + c))) {\n    return false;\n  }\n\n  // count distance via scalar multiplication\n  var distance = Math.sqrt(Math.pow((p1.x - m.x) * (p2.y - m.y) - (p2.x - m.x) * (p1.y - m.y), 2) / c);\n\n  return distance < accuracy ? true : false;\n}\n\nmodule.exports.Point = Point;\nmodule.exports.isInLine = isInLine;\n","/home/travis/build/npmtest/node-npmtest-svg2ttf/node_modules/svg2ttf/lib/ttf/tables/os2.js":"'use strict';\n\n// See documentation here: http://www.microsoft.com/typography/otspec/os2.htm\n\nvar _ = require('lodash');\nvar identifier = require('../utils.js').identifier;\nvar ByteBuffer = require('microbuffer');\n\n//get first glyph unicode\nfunction getFirstCharIndex(font) {\n  return Math.max(0, Math.min(0xffff, Math.abs(_.minBy(Object.keys(font.codePoints), function (point) {\n    return parseInt(point, 10);\n  }))));\n}\n\n//get last glyph unicode\nfunction getLastCharIndex(font) {\n  return Math.max(0, Math.min(0xffff, Math.abs(_.maxBy(Object.keys(font.codePoints), function (point) {\n    return parseInt(point, 10);\n  }))));\n}\n\nfunction createOS2Table(font) {\n\n  var buf = new ByteBuffer(86);\n\n  buf.writeUint16(1); //version\n  buf.writeInt16(font.avgWidth); // xAvgCharWidth\n  buf.writeUint16(font.weightClass); // usWeightClass\n  buf.writeUint16(font.widthClass); // usWidthClass\n  buf.writeInt16(font.fsType); // fsType\n  buf.writeInt16(font.ySubscriptXSize); // ySubscriptXSize\n  buf.writeInt16(font.ySubscriptYSize); //ySubscriptYSize\n  buf.writeInt16(font.ySubscriptXOffset); // ySubscriptXOffset\n  buf.writeInt16(font.ySubscriptYOffset); // ySubscriptYOffset\n  buf.writeInt16(font.ySuperscriptXSize); // ySuperscriptXSize\n  buf.writeInt16(font.ySuperscriptYSize); // ySuperscriptYSize\n  buf.writeInt16(font.ySuperscriptXOffset); // ySuperscriptXOffset\n  buf.writeInt16(font.ySuperscriptYOffset); // ySuperscriptYOffset\n  buf.writeInt16(font.yStrikeoutSize); // yStrikeoutSize\n  buf.writeInt16(font.yStrikeoutPosition); // yStrikeoutPosition\n  buf.writeInt16(font.familyClass); // sFamilyClass\n  buf.writeUint8(font.panose.familyType); // panose.bFamilyType\n  buf.writeUint8(font.panose.serifStyle); // panose.bSerifStyle\n  buf.writeUint8(font.panose.weight); // panose.bWeight\n  buf.writeUint8(font.panose.proportion); // panose.bProportion\n  buf.writeUint8(font.panose.contrast); // panose.bContrast\n  buf.writeUint8(font.panose.strokeVariation); // panose.bStrokeVariation\n  buf.writeUint8(font.panose.armStyle); // panose.bArmStyle\n  buf.writeUint8(font.panose.letterform); // panose.bLetterform\n  buf.writeUint8(font.panose.midline); // panose.bMidline\n  buf.writeUint8(font.panose.xHeight); // panose.bXHeight\n  // TODO: This field is used to specify the Unicode blocks or ranges based on the 'cmap' table.\n  buf.writeUint32(0); // ulUnicodeRange1\n  buf.writeUint32(0); // ulUnicodeRange2\n  buf.writeUint32(0); // ulUnicodeRange3\n  buf.writeUint32(0); // ulUnicodeRange4\n  buf.writeUint32(identifier('PfEd')); // achVendID, equal to PfEd\n  buf.writeUint16(font.fsSelection); // fsSelection\n  buf.writeUint16(getFirstCharIndex(font)); // usFirstCharIndex\n  buf.writeUint16(getLastCharIndex(font)); // usLastCharIndex\n  buf.writeInt16(font.ascent); // sTypoAscender\n  buf.writeInt16(font.descent); // sTypoDescender\n  buf.writeInt16(font.lineGap); // lineGap\n  // Enlarge win acscent/descent to avoid clipping\n  buf.writeInt16(Math.max(font.yMax, font.ascent)); // usWinAscent\n  buf.writeInt16(-Math.min(font.yMin, font.descent)); // usWinDescent\n  buf.writeInt32(1); // ulCodePageRange1, Latin 1\n  buf.writeInt32(0); // ulCodePageRange2\n\n  return buf;\n}\n\nmodule.exports = createOS2Table;\n","/home/travis/build/npmtest/node-npmtest-svg2ttf/node_modules/svg2ttf/lib/ttf/tables/cmap.js":"'use strict';\n\n// See documentation here: http://www.microsoft.com/typography/otspec/cmap.htm\n\nvar _ = require('lodash');\nvar ByteBuffer = require('microbuffer');\n\nfunction getIDByUnicode(font, unicode) {\n  return font.codePoints[unicode] ? font.codePoints[unicode].id : 0;\n}\n\n// Calculate character segments with non-interruptable chains of unicodes\nfunction getSegments(font, bounds) {\n  bounds = bounds || Number.MAX_VALUE;\n\n  var result = [];\n  var segment;\n\n  // prevEndCode only changes when a segment closes\n  _.forEach(font.codePoints, function (glyph, unicode) {\n    unicode = parseInt(unicode, 10);\n    if (unicode >= bounds) {\n      return false;\n    }\n    // Initialize first segment or add new segment if code \"hole\" is found\n    if (!segment || unicode !== (segment.end + 1)) {\n      if (segment) {\n        result.push(segment);\n      }\n      segment = {\n        start: unicode\n      };\n    }\n    segment.end = unicode;\n  });\n\n  // Need to finish the last segment\n  if (segment) {\n    result.push(segment);\n  }\n\n  _.forEach(result, function (segment) {\n    segment.length = segment.end - segment.start + 1;\n  });\n\n  return result;\n}\n\n// Returns an array of {unicode, glyph} sets for all valid code points up to bounds\nfunction getCodePoints(codePoints, bounds) {\n  bounds = bounds || Number.MAX_VALUE;\n\n  var result = [];\n\n  _.forEach(codePoints, function (glyph, unicode) {\n    unicode = parseInt(unicode, 10);\n    // Since this is a sparse array, iterating will only yield the valid code points\n    if (unicode > bounds) {\n      return false;\n    }\n    result.push({\n      unicode: unicode,\n      glyph: glyph\n    });\n  });\n  return result;\n}\n\nfunction bufferForTable(format, length) {\n  var fieldWidth = format === 8 || format === 10 || format === 12 || format === 13 ? 4 : 2;\n\n  length += (0\n    + fieldWidth // Format\n    + fieldWidth // Length\n    + fieldWidth // Language\n  );\n\n  var LANGUAGE = 0;\n  var buffer = new ByteBuffer(length);\n\n  var writer = fieldWidth === 4 ? buffer.writeUint32 : buffer.writeUint16;\n\n  // Format specifier\n  buffer.writeUint16(format);\n  if (fieldWidth === 4) {\n    // In case of formats 8.…, 10.…, 12.… and 13.…, this is the decimal part of the format number\n    // But since have not been any point releases, this can be zero in that case as well\n    buffer.writeUint16(0);\n  }\n  // Length\n  writer.call(buffer, length);\n  // Language code (0, only used for legacy quickdraw tables)\n  writer.call(buffer, LANGUAGE);\n\n  return buffer;\n}\n\nfunction createFormat0Table(font) {\n  var FORMAT = 0;\n\n  var i;\n\n  var length = 0xff + 1; //Format 0 maps only single-byte code points\n\n  var buffer = bufferForTable(FORMAT, length);\n\n  for (i = 0; i < length; i++) {\n    buffer.writeUint8(getIDByUnicode(font, i)); // existing char in table 0..255\n  }\n  return buffer;\n}\n\nfunction createFormat4Table(font) {\n  var FORMAT = 4;\n\n  var i;\n\n  var segments = getSegments(font, 0xFFFF);\n  var glyphIndexArrays = [];\n\n  _.forEach(segments, function (segment) {\n    var glyphIndexArray = [];\n\n    for (var unicode = segment.start; unicode <= segment.end; unicode++) {\n      glyphIndexArray.push(getIDByUnicode(font, unicode));\n    }\n    glyphIndexArrays.push(glyphIndexArray);\n  });\n\n  var segCount = segments.length + 1; // + 1 for the 0xFFFF section\n  var glyphIndexArrayLength = _.reduce(_.map(glyphIndexArrays, 'length'), function (result, count) { return result + count; }, 0);\n\n  var length = (0\n    + 2 // segCountX2\n    + 2 // searchRange\n    + 2 // entrySelector\n    + 2 // rangeShift\n    + 2 * segCount // endCodes\n    + 2 // Padding\n    + 2 * segCount //startCodes\n    + 2 * segCount //idDeltas\n    + 2 * segCount //idRangeOffsets\n    + 2 * glyphIndexArrayLength\n  );\n\n  var buffer = bufferForTable(FORMAT, length);\n\n  buffer.writeUint16(segCount * 2); // segCountX2\n  var maxExponent = Math.floor(Math.log(segCount) / Math.LN2);\n  var searchRange = 2 * Math.pow(2, maxExponent);\n\n  buffer.writeUint16(searchRange); // searchRange\n  buffer.writeUint16(maxExponent); // entrySelector\n  buffer.writeUint16(2 * segCount - searchRange); // rangeShift\n\n  // Array of end counts\n  _.forEach(segments, function (segment) {\n    buffer.writeUint16(segment.end);\n  });\n  buffer.writeUint16(0xFFFF); // endCountArray should be finished with 0xFFFF\n\n  buffer.writeUint16(0); // reservedPad\n\n  // Array of start counts\n  _.forEach(segments, function (segment) {\n    buffer.writeUint16(segment.start); //startCountArray\n  });\n  buffer.writeUint16(0xFFFF); // startCountArray should be finished with 0xFFFF\n\n  // Array of deltas. Leave it zero to not complicate things when using the glyph index array\n  for (i = 0; i < segments.length; i++) {\n    buffer.writeUint16(0); // delta is always zero because we use the glyph array\n  }\n  buffer.writeUint16(1); // idDeltaArray should be finished with 1\n\n  // Array of range offsets\n  var offset = 0;\n\n  for (i = 0; i < segments.length; i++) {\n    buffer.writeUint16(2 * ((segments.length - i + 1) + offset));\n    offset += glyphIndexArrays[i].length;\n  }\n  buffer.writeUint16(0); // rangeOffsetArray should be finished with 0\n\n  _.forEach(glyphIndexArrays, function (glyphIndexArray) {\n    _.forEach(glyphIndexArray, function (glyphId) {\n      buffer.writeUint16(glyphId);\n    });\n  });\n\n  return buffer;\n}\n\nfunction createFormat12Table(font) {\n  var FORMAT = 12;\n\n  var codePoints = getCodePoints(font.codePoints);\n\n  var length = (0\n    + 4 // nGroups\n    + 4 * codePoints.length // startCharCode\n    + 4 * codePoints.length // endCharCode\n    + 4 * codePoints.length // startGlyphCode\n  );\n\n  var buffer = bufferForTable(FORMAT, length);\n\n  buffer.writeUint32(codePoints.length); // nGroups\n  _.forEach(codePoints, function (codePoint) {\n    buffer.writeUint32(codePoint.unicode); // startCharCode\n    buffer.writeUint32(codePoint.unicode); // endCharCode\n    buffer.writeUint32(codePoint.glyph.id); // startGlyphCode\n  });\n\n  return buffer;\n}\n\nfunction createCMapTable(font) {\n  var TABLE_HEAD = (0\n    + 2 // platform\n    + 2 // encoding\n    + 4 // offset\n  );\n\n  var singleByteTable = createFormat0Table(font);\n  var twoByteTable = createFormat4Table(font);\n  var fourByteTable = createFormat12Table(font);\n\n  // Subtable headers must be sorted by platformID, encodingID\n  var tableHeaders = [\n    // subtable 4, unicode\n    {\n      platformID: 0,\n      encodingID: 3,\n      table: twoByteTable\n    },\n    // subtable 12, unicode\n    {\n      platformID: 0,\n      encodingID: 4,\n      table: fourByteTable\n    },\n    // subtable 0, mac standard\n    {\n      platformID: 1,\n      encodingID: 0,\n      table: singleByteTable\n    },\n    // subtable 4, windows standard, identical to the unicode table\n    {\n      platformID: 3,\n      encodingID: 1,\n      table: twoByteTable\n    },\n    // subtable 12, windows ucs4\n    {\n      platformID: 3,\n      encodingID: 10,\n      table: fourByteTable\n    }\n  ];\n\n  var tables = [\n    twoByteTable,\n    singleByteTable,\n    fourByteTable\n  ];\n\n  var tableOffset = (0\n    + 2 // version\n    + 2 // number of subtable headers\n    + tableHeaders.length * TABLE_HEAD\n  );\n\n  // Calculate offsets for each table\n  _.forEach(tables, function (table) {\n    table._tableOffset = tableOffset;\n    tableOffset += table.length;\n  });\n\n  var length = tableOffset;\n\n  var buffer = new ByteBuffer(length);\n\n  // Write table header.\n  buffer.writeUint16(0); // version\n  buffer.writeUint16(tableHeaders.length); // count\n\n  // Write subtable headers\n  _.forEach(tableHeaders, function (header) {\n    buffer.writeUint16(header.platformID); // platform\n    buffer.writeUint16(header.encodingID); // encoding\n    buffer.writeUint32(header.table._tableOffset); // offset\n  });\n\n  // Write subtables\n  _.forEach(tables, function (table) {\n    buffer.writeBytes(table.buffer);\n  });\n\n  return buffer;\n}\n\nmodule.exports = createCMapTable;\n","/home/travis/build/npmtest/node-npmtest-svg2ttf/node_modules/svg2ttf/lib/ttf/tables/glyf.js":"'use strict';\n\n// See documentation here: http://www.microsoft.com/typography/otspec/glyf.htm\n\nvar _ = require('lodash');\nvar ByteBuffer = require('microbuffer');\n\nfunction getFlags(glyph) {\n  var result = [];\n\n  _.forEach(glyph.ttfContours, function (contour) {\n    _.forEach(contour, function (point) {\n      var flag = point.onCurve ? 1 : 0;\n\n      if (point.x === 0) {\n        flag += 16;\n      } else {\n        if (-0xFF <= point.x && point.x <= 0xFF) {\n          flag += 2; // the corresponding x-coordinate is 1 byte long\n        }\n        if (point.x > 0 && point.x <= 0xFF) {\n          flag += 16; // If x-Short Vector is set, this bit describes the sign of the value, with 1 equalling positive and 0 negative\n        }\n      }\n      if (point.y === 0) {\n        flag += 32;\n      } else {\n        if (-0xFF <= point.y && point.y <= 0xFF) {\n          flag += 4; // the corresponding y-coordinate is 1 byte long\n        }\n        if (point.y > 0 && point.y <= 0xFF) {\n          flag += 32; // If y-Short Vector is set, this bit describes the sign of the value, with 1 equalling positive and 0 negative.\n        }\n      }\n      result.push(flag);\n    });\n  });\n  return result;\n}\n\n//repeating flags can be packed\nfunction compactFlags(flags) {\n  var result = [];\n  var prevFlag = -1;\n  var firstRepeat = false;\n\n  _.forEach(flags, function (flag) {\n    if (prevFlag === flag) {\n      if (firstRepeat) {\n        result[result.length - 1] += 8; //current flag repeats previous one, need to set 3rd bit of previous flag and set 1 to the current one\n        result.push(1);\n        firstRepeat = false;\n      } else {\n        result[result.length - 1]++; //when flag is repeating second or more times, we need to increase the last flag value\n      }\n    } else {\n      firstRepeat = true;\n      prevFlag = flag;\n      result.push(flag);\n    }\n  });\n  return result;\n}\n\nfunction getCoords(glyph, coordName) {\n  var result = [];\n\n  _.forEach(glyph.ttfContours, function (contour) {\n    result.push.apply(result, _.map(contour, coordName));\n  });\n  return result;\n}\n\nfunction compactCoords(coords) {\n  return _.filter(coords, function (coord) {\n    return coord !== 0;\n  });\n}\n\n//calculates length of glyph data in GLYF table\nfunction glyphDataSize(glyph) {\n  // Ignore glyphs without outlines. These will get a length of zero in the “loca” table\n  if (!glyph.contours.length) {\n    return 0;\n  }\n\n  var result = 12; //glyph fixed properties\n\n  result += glyph.contours.length * 2; //add contours\n\n  _.forEach(glyph.ttf_x, function (x) {\n    //add 1 or 2 bytes for each coordinate depending of its size\n    result += ((-0xFF <= x && x <= 0xFF)) ? 1 : 2;\n  });\n\n  _.forEach(glyph.ttf_y, function (y) {\n    //add 1 or 2 bytes for each coordinate depending of its size\n    result += ((-0xFF <= y && y <= 0xFF)) ? 1 : 2;\n  });\n\n  // Add flags length to glyph size.\n  result += glyph.ttf_flags.length;\n\n  if (result % 4 !== 0) { // glyph size must be divisible by 4.\n    result += 4 - result % 4;\n  }\n  return result;\n}\n\nfunction tableSize(font) {\n  var result = 0;\n\n  _.forEach(font.glyphs, function (glyph) {\n    glyph.ttf_size = glyphDataSize(glyph);\n    result += glyph.ttf_size;\n  });\n  font.ttf_glyph_size = result; //sum of all glyph lengths\n  return result;\n}\n\nfunction createGlyfTable(font) {\n\n  _.forEach(font.glyphs, function (glyph) {\n    glyph.ttf_flags = getFlags(glyph);\n    glyph.ttf_flags = compactFlags(glyph.ttf_flags);\n    glyph.ttf_x = getCoords(glyph, 'x');\n    glyph.ttf_x = compactCoords(glyph.ttf_x);\n    glyph.ttf_y = getCoords(glyph, 'y');\n    glyph.ttf_y = compactCoords(glyph.ttf_y);\n  });\n\n  var buf = new ByteBuffer(tableSize(font));\n\n  _.forEach(font.glyphs, function (glyph) {\n\n    // Ignore glyphs without outlines. These will get a length of zero in the “loca” table\n    if (!glyph.contours.length) {\n      return;\n    }\n\n    var offset = buf.tell();\n\n    buf.writeInt16(glyph.contours.length); // numberOfContours\n    buf.writeInt16(glyph.xMin); // xMin\n    buf.writeInt16(glyph.yMin); // yMin\n    buf.writeInt16(glyph.xMax); // xMax\n    buf.writeInt16(glyph.yMax); // yMax\n\n    // Array of end points\n    var endPtsOfContours = -1;\n\n    var ttfContours = glyph.ttfContours;\n\n    _.forEach(ttfContours, function (contour) {\n      endPtsOfContours += contour.length;\n      buf.writeInt16(endPtsOfContours);\n    });\n\n    buf.writeInt16(0); // instructionLength, is not used here\n\n    // Array of flags\n    _.forEach(glyph.ttf_flags, function (flag) {\n      buf.writeInt8(flag);\n    });\n\n    // Array of X relative coordinates\n    _.forEach(glyph.ttf_x, function (x) {\n      if (-0xFF <= x && x <= 0xFF) {\n        buf.writeUint8(Math.abs(x));\n      } else {\n        buf.writeInt16(x);\n      }\n    });\n\n    // Array of Y relative coordinates\n    _.forEach(glyph.ttf_y, function (y) {\n      if (-0xFF <= y && y <= 0xFF) {\n        buf.writeUint8(Math.abs(y));\n      } else {\n        buf.writeInt16(y);\n      }\n    });\n\n    var tail = (buf.tell() - offset) % 4;\n\n    if (tail !== 0) { // glyph size must be divisible by 4.\n      for (; tail < 4; tail++) {\n        buf.writeUint8(0);\n      }\n    }\n  });\n  return buf;\n}\n\nmodule.exports = createGlyfTable;\n","/home/travis/build/npmtest/node-npmtest-svg2ttf/node_modules/svg2ttf/lib/ttf/tables/head.js":"'use strict';\n\n// See documentation here: http://www.microsoft.com/typography/otspec/head.htm\n\nvar ByteBuffer = require('microbuffer');\n\nfunction dateToUInt64(date) {\n  var startDate = new Date('1904-01-01T00:00:00.000Z');\n\n  return Math.floor((date - startDate) / 1000);\n}\n\nfunction createHeadTable(font) {\n\n  var buf = new ByteBuffer(54); // fixed table length\n\n  buf.writeInt32(0x10000); // version\n  buf.writeInt32(font.revision * 0x10000); // fontRevision\n  buf.writeUint32(0); // checkSumAdjustment\n  buf.writeUint32(0x5F0F3CF5); // magicNumber\n  // FLag meanings:\n  // Bit 0: Baseline for font at y=0;\n  // Bit 1: Left sidebearing point at x=0;\n  // Bit 3: Force ppem to integer values for all internal scaler math; may use fractional ppem sizes if this bit is clear;\n  buf.writeUint16(0x000B); // flags\n  buf.writeUint16(font.unitsPerEm); // unitsPerEm\n  buf.writeUint64(dateToUInt64(font.createdDate)); // created\n  buf.writeUint64(dateToUInt64(font.modifiedDate)); // modified\n  buf.writeInt16(font.xMin); // xMin\n  buf.writeInt16(font.yMin); // yMin\n  buf.writeInt16(font.xMax); // xMax\n  buf.writeInt16(font.yMax); // yMax\n  buf.writeUint16(font.macStyle); //macStyle\n  buf.writeUint16(font.lowestRecPPEM); // lowestRecPPEM\n  buf.writeInt16(2); // fontDirectionHint\n  buf.writeInt16(font.ttf_glyph_size < 0x20000 ? 0 : 1); // indexToLocFormat, 0 for short offsets, 1 for long offsets\n  buf.writeInt16(0); // glyphDataFormat\n\n  return buf;\n}\n\nmodule.exports = createHeadTable;\n","/home/travis/build/npmtest/node-npmtest-svg2ttf/node_modules/svg2ttf/lib/ttf/tables/hhea.js":"'use strict';\n\n// See documentation here: http://www.microsoft.com/typography/otspec/hhea.htm\n\nvar ByteBuffer = require('microbuffer');\n\nfunction createHHeadTable(font) {\n\n  var buf = new ByteBuffer(36); // fixed table length\n\n  buf.writeInt32(0x10000); // version\n  buf.writeInt16(font.ascent); // ascent\n  buf.writeInt16(font.descent); // descend\n  // Non zero lineGap causes offset in IE, https://github.com/fontello/svg2ttf/issues/37\n  buf.writeInt16(0); // lineGap\n  buf.writeUint16(font.maxWidth); // advanceWidthMax\n  buf.writeInt16(font.minLsb); // minLeftSideBearing\n  buf.writeInt16(font.minRsb); // minRightSideBearing\n  buf.writeInt16(font.maxExtent); // xMaxExtent\n  buf.writeInt16(1); // caretSlopeRise\n  buf.writeInt16(0); // caretSlopeRun\n  buf.writeUint32(0); // reserved1\n  buf.writeUint32(0); // reserved2\n  buf.writeUint16(0); // reserved3\n  buf.writeInt16(0); // metricDataFormat\n  buf.writeUint16(font.glyphs.length); // numberOfHMetrics\n\n  return buf;\n}\n\nmodule.exports = createHHeadTable;\n","/home/travis/build/npmtest/node-npmtest-svg2ttf/node_modules/svg2ttf/lib/ttf/tables/hmtx.js":"'use strict';\n\n// See documentation here: http://www.microsoft.com/typography/otspec/hmtx.htm\n\nvar _ = require('lodash');\nvar ByteBuffer = require('microbuffer');\n\nfunction createHtmxTable(font) {\n\n  var buf = new ByteBuffer(font.glyphs.length * 4);\n\n  _.forEach(font.glyphs, function (glyph) {\n    buf.writeUint16(glyph.width); //advanceWidth\n    buf.writeInt16(glyph.xMin); //lsb\n  });\n  return buf;\n}\n\nmodule.exports = createHtmxTable;\n","/home/travis/build/npmtest/node-npmtest-svg2ttf/node_modules/svg2ttf/lib/ttf/tables/loca.js":"'use strict';\n\n// See documentation here: http://www.microsoft.com/typography/otspec/loca.htm\n\nvar _ = require('lodash');\nvar ByteBuffer = require('microbuffer');\n\nfunction tableSize(font, isShortFormat) {\n  var result = (font.glyphs.length + 1) * (isShortFormat ? 2 : 4); // by glyph count + tail\n\n  return result;\n}\n\nfunction createLocaTable(font) {\n\n  var isShortFormat = font.ttf_glyph_size < 0x20000;\n\n  var buf = new ByteBuffer(tableSize(font, isShortFormat));\n\n  var location = 0;\n\n  // Array of offsets in GLYF table for each glyph\n  _.forEach(font.glyphs, function (glyph) {\n    if (isShortFormat) {\n      buf.writeUint16(location);\n      location += glyph.ttf_size / 2; // actual location must be divided to 2 in short format\n    } else {\n      buf.writeUint32(location);\n      location += glyph.ttf_size; //actual location is stored as is in long format\n    }\n  });\n\n  // The last glyph location is stored to get last glyph length\n  if (isShortFormat) {\n    buf.writeUint16(location);\n  } else {\n    buf.writeUint32(location);\n  }\n\n  return buf;\n}\n\nmodule.exports = createLocaTable;\n","/home/travis/build/npmtest/node-npmtest-svg2ttf/node_modules/svg2ttf/lib/ttf/tables/maxp.js":"'use strict';\n\n// See documentation here: http://www.microsoft.com/typography/otspec/maxp.htm\n\nvar _ = require('lodash');\nvar ByteBuffer = require('microbuffer');\n\n// Find max points in glyph TTF contours.\nfunction getMaxPoints(font) {\n  return _.max(_.map(font.glyphs, function (glyph) {\n    return _.reduce(glyph.ttfContours, function (sum, ctr) { return sum + ctr.length; }, 0);\n  }));\n}\n\nfunction getMaxContours(font) {\n  return _.max(_.map(font.glyphs, function (glyph) {\n    return glyph.ttfContours.length;\n  }));\n}\n\nfunction createMaxpTable(font) {\n\n  var buf = new ByteBuffer(32);\n\n  buf.writeInt32(0x10000); // version\n  buf.writeUint16(font.glyphs.length); // numGlyphs\n  buf.writeUint16(getMaxPoints(font)); // maxPoints\n  buf.writeUint16(getMaxContours(font)); // maxContours\n  buf.writeUint16(0); // maxCompositePoints\n  buf.writeUint16(0); // maxCompositeContours\n  buf.writeUint16(2); // maxZones\n  buf.writeUint16(0); // maxTwilightPoints\n  // It is unclear how to calculate maxStorage, maxFunctionDefs and maxInstructionDefs.\n  // These are magic constants now, with values exceeding values from FontForge\n  buf.writeUint16(10); // maxStorage\n  buf.writeUint16(10); // maxFunctionDefs\n  buf.writeUint16(0); // maxInstructionDefs\n  buf.writeUint16(255); // maxStackElements\n  buf.writeUint16(0); // maxSizeOfInstructions\n  buf.writeUint16(0); // maxComponentElements\n  buf.writeUint16(0); // maxComponentDepth\n\n  return buf;\n}\n\nmodule.exports = createMaxpTable;\n","/home/travis/build/npmtest/node-npmtest-svg2ttf/node_modules/svg2ttf/lib/ttf/tables/name.js":"'use strict';\n\n// See documentation here: http://www.microsoft.com/typography/otspec/name.htm\n\nvar _ = require('lodash');\nvar ByteBuffer = require('microbuffer');\nvar Str = require('../../str');\n\nvar TTF_NAMES = {\n  COPYRIGHT: 0,\n  FONT_FAMILY: 1,\n  ID: 3,\n  DESCRIPTION: 10,\n  URL_VENDOR: 11\n};\n\nfunction tableSize(names) {\n  var result = 6; // table header\n\n  _.forEach(names, function (name) {\n    result += 12 + name.data.length; //name header and data\n  });\n  return result;\n}\n\nfunction getStrings(name, id) {\n  var result = [];\n  var str = new Str(name);\n\n  result.push({ data: str.toUTF8Bytes(), id: id, platformID : 1, encodingID : 0, languageID : 0 }); //mac standard\n  result.push({ data: str.toUCS2Bytes(), id: id, platformID : 3, encodingID : 1, languageID : 0x409 }); //windows standard\n  return result;\n}\n\n// Collect font names\nfunction getNames(font) {\n  var result = [];\n\n  if (font.copyright) {\n    result.push.apply(result, getStrings(font.copyright, TTF_NAMES.COPYRIGHT));\n  }\n  if (font.familyName) {\n    result.push.apply(result, getStrings(font.familyName, TTF_NAMES.FONT_FAMILY));\n  }\n  if (font.id) {\n    result.push.apply(result, getStrings(font.id, TTF_NAMES.ID));\n  }\n  result.push.apply(result, getStrings('Generated by svg2ttf from Fontello project.', TTF_NAMES.DESCRIPTION));\n  result.push.apply(result, getStrings('http://fontello.com', TTF_NAMES.URL_VENDOR));\n\n  _.forEach(font.sfntNames, function (sfntName) {\n    result.push.apply(result, getStrings(sfntName.value, sfntName.id));\n  });\n\n  result.sort(function (a, b) {\n    var orderFields = [ 'platformID', 'encodingID', 'languageID', 'id' ];\n    var i;\n\n    for (i = 0; i < orderFields.length; i++) {\n      if (a[orderFields[i]] !== b[orderFields[i]]) {\n        return a[orderFields[i]] < b[orderFields[i]] ? -1 : 1;\n      }\n    }\n    return 0;\n  });\n\n  return result;\n}\n\nfunction createNameTable(font) {\n\n  var names = getNames(font);\n\n  var buf = new ByteBuffer(tableSize(names));\n\n  buf.writeUint16(0); // formatSelector\n  buf.writeUint16(names.length); // nameRecordsCount\n  var offsetPosition = buf.tell();\n\n  buf.writeUint16(0); // offset, will be filled later\n  var nameOffset = 0;\n\n  _.forEach(names, function (name) {\n    buf.writeUint16(name.platformID); // platformID\n    buf.writeUint16(name.encodingID); // platEncID\n    buf.writeUint16(name.languageID); // languageID, English (USA)\n    buf.writeUint16(name.id); // nameID\n    buf.writeUint16(name.data.length); // reclength\n    buf.writeUint16(nameOffset); // offset\n    nameOffset += name.data.length;\n  });\n  var actualStringDataOffset = buf.tell();\n\n  //Array of bytes with actual string data\n  _.forEach(names, function (name) {\n    buf.writeBytes(name.data);\n  });\n\n  //write actual string data offset\n  buf.seek(offsetPosition);\n  buf.writeUint16(actualStringDataOffset); // offset\n\n  return buf;\n}\n\nmodule.exports = createNameTable;\n","/home/travis/build/npmtest/node-npmtest-svg2ttf/node_modules/svg2ttf/lib/str.js":"'use strict';\n\nfunction Str(str) {\n  if (!(this instanceof Str)) {\n    return new Str(str);\n  }\n\n  this.str = str;\n\n  this.toUTF8Bytes = function () {\n\n    var byteArray = [];\n\n    for (var i = 0; i < str.length; i++) {\n      if (str.charCodeAt(i) <= 0x7F) {\n        byteArray.push(str.charCodeAt(i));\n      } else {\n        var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');\n\n        for (var j = 0; j < h.length; j++) {\n          byteArray.push(parseInt(h[j], 16));\n        }\n      }\n    }\n    return byteArray;\n  };\n\n  this.toUCS2Bytes = function () {\n    // Code is taken here:\n    // http://stackoverflow.com/questions/6226189/how-to-convert-a-string-to-bytearray\n    var byteArray = [];\n    var ch;\n\n    for (var i = 0; i < str.length; ++i) {\n      ch = str.charCodeAt(i);  // get char\n      byteArray.push(ch >> 8);\n      byteArray.push(ch & 0xFF);\n    }\n    return byteArray;\n  };\n}\n\nmodule.exports = Str;\n","/home/travis/build/npmtest/node-npmtest-svg2ttf/node_modules/svg2ttf/lib/ttf/tables/post.js":"'use strict';\n\n// See documentation here: http://www.microsoft.com/typography/otspec/post.htm\n\nvar _ = require('lodash');\nvar ByteBuffer = require('microbuffer');\n\nfunction tableSize(font, names) {\n  var result = 36; // table header\n\n  result += font.glyphs.length * 2; // name declarations\n  _.forEach(names, function (name) {\n    result += name.length;\n  });\n  return result;\n}\n\nfunction pascalString(str) {\n  var bytes = [];\n  var len = str ? (str.length < 256 ? str.length : 255) : 0; //length in Pascal string is limited with 255\n\n  bytes.push(len);\n  for (var i = 0; i < len; i++) {\n    var char = str.charCodeAt(i);\n\n    bytes.push(char < 128 ? char : 95); //non-ASCII characters are substituted with '_'\n  }\n  return bytes;\n}\n\nfunction createPostTable(font) {\n\n  var names = [];\n\n  _.forEach(font.glyphs, function (glyph) {\n    if (glyph.unicode !== 0) {\n      names.push(pascalString(glyph.name));\n    }\n  });\n\n  var buf = new ByteBuffer(tableSize(font, names));\n\n  buf.writeInt32(0x20000); // formatType,  version 2.0\n  buf.writeInt32(font.italicAngle); // italicAngle\n  buf.writeInt16(font.underlinePosition); // underlinePosition\n  buf.writeInt16(font.underlineThickness); // underlineThickness\n  buf.writeUint32(font.isFixedPitch); // isFixedPitch\n  buf.writeUint32(0); // minMemType42\n  buf.writeUint32(0); // maxMemType42\n  buf.writeUint32(0); // minMemType1\n  buf.writeUint32(0); // maxMemType1\n  buf.writeUint16(font.glyphs.length); // numberOfGlyphs\n\n  // Array of glyph name indexes\n  var index = 258; // first index of custom glyph name, it is calculated as glyph name index + 258\n\n  _.forEach(font.glyphs, function (glyph) {\n    if (glyph.unicode === 0) {\n      buf.writeUint16(0);// missed element should have .notDef name in the Macintosh standard order.\n    } else {\n      buf.writeUint16(index++);\n    }\n  });\n\n  // Array of glyph name indexes\n  _.forEach(names, function (name) {\n    buf.writeBytes(name);\n  });\n\n  return buf;\n}\n\nmodule.exports = createPostTable;\n","/home/travis/build/npmtest/node-npmtest-svg2ttf/node_modules/svg2ttf/svg2ttf.js":"#!/usr/bin/env node\n/*\n Author: Sergey Batishchev <sergej.batishchev@gmail.com>\n\n Written for fontello.com project.\n */\n\n/*eslint-disable no-console*/\n\n'use strict';\n\n\nvar fs = require('fs');\nvar ArgumentParser = require('argparse').ArgumentParser;\n\nvar svg2ttf = require('./');\n\n\nvar parser = new ArgumentParser({\n  version: require('./package.json').version,\n  addHelp: true,\n  description: 'SVG to TTF font converter'\n});\n\nparser.addArgument(\n  [ '-c', '--copyright' ],\n  {\n    help: 'Copyright text',\n    required: false\n  }\n);\n\nparser.addArgument(\n  [ '--ts' ],\n  {\n    help: 'Override font creation time (Unix time stamp)',\n    required: false,\n    type: 'int'\n  }\n);\n\nparser.addArgument(\n  [ '--vs' ],\n  {\n    help: 'Override default font version string (Version 1.0), can be \"x.y\" or \"Version x.y\"',\n    required: false,\n    type: 'string'\n  }\n);\n\nparser.addArgument(\n  [ 'infile' ],\n  {\n    nargs: 1,\n    help: 'Input file'\n  }\n);\n\nparser.addArgument(\n  [ 'outfile' ],\n  {\n    nargs: 1,\n    help: 'Output file'\n  }\n);\n\n\nvar args = parser.parseArgs();\nvar svg;\nvar options = {};\n\ntry {\n  svg = fs.readFileSync(args.infile[0], 'utf-8');\n} catch (e) {\n  console.error(\"Can't open input file (%s)\", args.infile[0]);\n  process.exit(1);\n}\n\nif (args.copyright) options.copyright = args.copyright;\n\nif (args.ts !== null) options.ts = args.ts;\n\nif (args.vs) options.version = args.vs;\n\nfs.writeFileSync(args.outfile[0], new Buffer(svg2ttf(svg, options).buffer));\n"}